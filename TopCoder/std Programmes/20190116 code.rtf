{\rtf1\ansi\ansicpg936\deff0\nouicompat\deflang1033\deflangfe2052{\fonttbl{\f0\fnil\fcharset134 \'cb\'ce\'cc\'e5;}}
{\*\generator Riched20 10.0.17134}\viewkind4\uc1 
\pard\sa200\sl276\slmult1\f0\fs22\lang2052 #include <cstdio>\par
#include <algorithm>\par
#include <vector>\par
using namespace std;\par
class TheSoccerDivOne\{\par
\tab public:\par
\tab static const int NMax=50;\par
\tab static const int delta=2*NMax+1;\par
\tab int n;\par
\tab int dp[NMax+1][NMax*4+3][NMax*2+1];\par
\tab //dp[i][j][k]\par
\tab //\'c7\'b0i\'b8\'f6\'c8\'cb\'a3\'ac\'ca\'e4\'d3\'ae\'c7\'e9\'bf\'f6\'ce\'aaj\'a3\'ac\'ce\'b4\'c6\'a5\'c5\'e4\'b5\'c4\'c6\'bd\'be\'d6k\par
\tab int find(vector<int> points)\{\par
\tab\tab n=points.size();\par
\tab\tab int line=points[0]+12;\par
\tab\tab for (int j=-n*2;j<=n*2;j++)\par
\tab\tab\tab for (int k=0;k<=n*2;k++)\par
\tab\tab\tab\tab dp[n][j+delta][k]=~0u>>2;\par
\tab\tab dp[n][0+delta][0]=0;\par
\tab\tab for (int i=n-1;i>0;i--)\{\par
\tab\tab\tab for (int j=-n*2;j<=n*2;j++)\par
\tab\tab\tab\tab for (int k=0;k<=n*2;k++)\{\par
\tab\tab\tab\tab\tab int &r=dp[i][j+delta][k];\par
\tab\tab\tab\tab\tab r=~0u>>2;\par
\tab\tab\tab\tab\tab for (int w=0;w<=4;w++)\par
\tab\tab\tab\tab\tab\tab for (int l=0;w+l<=4;l++)if (j-w+l>=-n-n && j-w+l<=n+n)\{\par
\tab\tab\tab\tab\tab\tab\tab int d=4-w-l;\par
\tab\tab\tab\tab\tab\tab\tab //\'c3\'b6\'be\'d9\'b5\'dai\'b8\'f6\'c8\'cb\'b5\'c4\'d3\'ae\'a1\'a2\'ca\'e4\'a1\'a2\'c6\'bd\'be\'d6\'ca\'fd\par
\tab\tab\tab\tab\tab\tab\tab int c=points[i]+w*3+d>line?1:0;\par
\tab\tab\tab\tab\tab\tab\tab for (int m=0;m<=d;m++)\{\par
\tab\tab\tab\tab\tab\tab\tab\tab if (k>=m && k+d-2*m<=n)\{\par
\tab\tab\tab\tab\tab\tab\tab\tab\tab r=min(r,dp[i+1][j-w+l+delta][k+d-2*m]+c);\par
\tab\tab\tab\tab\tab\tab\tab\tab\}\par
\tab\tab\tab\tab\tab\tab\tab\}\par
\tab\tab\tab\tab\tab\tab\}\par
\tab\tab\tab\tab\}\par
\tab\tab\}\par
\tab\tab return dp[1][-4+delta][0]+1;\par
\tab\}\par
\}me;\par
int work()\par
\{\par
\tab int a[50]=\{123456, 123462, 123459, 123456, 123462, 123456, 123456, 123460, 123456, 123456, 123465, 123462, 123460, 123458, 123462, 123456, 123458, 123457, 123467, 123459, 123456, 123464, 123460, 123461, 123456, 123456, 123458, 123462, 123464, 123464, 123466, 123459, 123456, 123456, 123464, 123456, 123462, 123464, 123459, 123462, 123462, 123460, 123464, 123462, 123459, 123465, 123459, 123464, 123466, 123464\};\par
\tab printf("%d\\n",me.find(vector<int>(a,a+50)));\par
\tab printf("%d\\n",(int)clock());\par
\tab return 0;\par
\}\par
int main()\{return work();\}\par
\par
#include <vector>\par
#include <list>\par
#include <map>\par
#include <set>\par
#include <queue>\par
#include <deque>\par
#include <stack>\par
#include <bitset>\par
#include <algorithm>\par
#include <functional>\par
#include <numeric>\par
#include <utility>\par
#include <sstream>\par
#include <iostream>\par
#include <iomanip>\par
#include <cstdio>\par
#include <cmath>\par
#include <cstdlib>\par
#include <ctime>\par
\par
using namespace std;\par
\par
const int oo=10000000;\par
pair<int,int> p[55];\par
int f[55];\par
int opt[55][105][105][5];\par
int n;\par
\par
class TheSoccerDivOne \{\par
public:\par
\par
\tab void renew(int &a,int b)\par
\tab\{\par
\tab\tab if (a>b) a=b;\par
\tab\}\par
\tab\par
\tab int find(vector <int> points) \par
\tab\{\par
\tab\tab n=points.size();\par
\tab\tab for (int i=0;i<n;i++) p[i]=make_pair(-points[i],i);\par
\tab\tab p[0].first-=12;\par
\tab\tab sort(p,p+n);\par
\tab\tab int rank;\par
\tab\tab for (int i=0;i<n;i++)\par
\tab\tab if (p[i].second==0) rank=i;\par
\tab\tab if (rank>=n-rank-1) return rank+1;\par
\tab\tab\par
\tab\tab int m=0;\par
\tab\tab for (int i=0;i<n;i++) \par
\tab\tab\tab f[++m]=-p[rank].first+p[i].first;\par
\tab\tab for (int i=1;i<=rank+1;i++) f[i]=1000000;\par
\tab\tab\par
\tab\tab for (int i=0;i<=m;i++)\par
\tab\tab for (int j=0;j<=2*m;j++)\par
\tab\tab for (int k=0;k<=2*m;k++)\par
\tab\tab for (int l=0;l<5;l++)\par
\tab\tab\tab opt[i][j][k][l]=oo;\par
\tab\tab opt[0][0][0][0]=0;\par
\tab\tab\par
\tab\tab for (int i=0;i<m;i++)\par
\tab\tab for (int j=0;j<=2*m;j++)\par
\tab\tab for (int k=0;k<=2*m;k++)\par
\tab\tab for (int l=0;l<5;l++)\par
\tab\tab if (opt[i][j][k][l]<oo)\par
\tab\tab for (int u=0;u<=4;u++)\par
\tab\tab for (int v=0;u+v<=4;v++)\par
\tab\tab\tab renew(opt[i+1][j+u][k+v][max(l,4-u-v)],opt[i][j][k][l]+(3*u+(4-u-v)>f[i+1]));\par
\tab\tab int res=oo;\par
\tab\tab for (int i=0;i<=m*2;i++)\par
\tab\tab for (int j=0;j<5;j++)\par
\tab\tab if (m*2-i>=j) res=min(res,rank+1+opt[m][i][i][j]);\par
\tab\tab return res;\par
\tab\}\par
\};\par
\par
\par
// BEGIN KAWIGIEDIT TESTING\par
// Generated by KawigiEdit 2.1.4 (beta) modified by pivanof\par
bool KawigiEdit_RunTest(int testNum, vector <int> p0, bool hasAnswer, int p1) \{\par
\tab cout << "Test " << testNum << ": [" << "\{";\par
\tab for (int i = 0; int(p0.size()) > i; ++i) \{\par
\tab\tab if (i > 0) \{\par
\tab\tab\tab cout << ",";\par
\tab\tab\}\par
\tab\tab cout << p0[i];\par
\tab\}\par
\tab cout << "\}";\par
\tab cout << "]" << endl;\par
\tab TheSoccerDivOne *obj;\par
\tab int answer;\par
\tab obj = new TheSoccerDivOne();\par
\tab clock_t startTime = clock();\par
\tab answer = obj->find(p0);\par
\tab clock_t endTime = clock();\par
\tab delete obj;\par
\tab bool res;\par
\tab res = true;\par
\tab cout << "Time: " << double(endTime - startTime) / CLOCKS_PER_SEC << " seconds" << endl;\par
\tab if (hasAnswer) \{\par
\tab\tab cout << "Desired answer:" << endl;\par
\tab\tab cout << "\\t" << p1 << endl;\par
\tab\}\par
\tab cout << "Your answer:" << endl;\par
\tab cout << "\\t" << answer << endl;\par
\tab if (hasAnswer) \{\par
\tab\tab res = answer == p1;\par
\tab\}\par
\tab if (!res) \{\par
\tab\tab cout << "DOESN'T MATCH!!!!" << endl;\par
\tab\} else if (double(endTime - startTime) / CLOCKS_PER_SEC >= 2) \{\par
\tab\tab cout << "FAIL the timeout" << endl;\par
\tab\tab res = false;\par
\tab\} else if (hasAnswer) \{\par
\tab\tab cout << "Match :-)" << endl;\par
\tab\} else \{\par
\tab\tab cout << "OK, but is it right?" << endl;\par
\tab\}\par
\tab cout << "" << endl;\par
\tab return res;\par
\}\par
int main() \{\par
\tab bool all_right;\par
\tab all_right = true;\par
\tab\par
\tab vector <int> p0;\par
\tab int p1;\par
\tab\par
\tab\{\par
\tab // ----- test 0 -----\par
\tab int t0[] = \{5,17\};\par
\tab\tab\tab p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));\par
\tab p1 = 1;\par
\tab all_right = KawigiEdit_RunTest(0, p0, true, p1) && all_right;\par
\tab // ------------------\par
\tab\}\par
\tab\par
\tab\{\par
\tab // ----- test 1 -----\par
\tab int t0[] = \{5,18,21,19\};\par
\tab\tab\tab p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));\par
\tab p1 = 4;\par
\tab all_right = KawigiEdit_RunTest(1, p0, true, p1) && all_right;\par
\tab // ------------------\par
\tab\}\par
\tab\par
\tab\{\par
\tab // ----- test 2 -----\par
\tab int t0[] = \{4,1,5\};\par
\tab\tab\tab p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));\par
\tab p1 = 1;\par
\tab all_right = KawigiEdit_RunTest(2, p0, true, p1) && all_right;\par
\tab // ------------------\par
\tab\}\par
\tab\par
\tab\{\par
\tab // ----- test 3 -----\par
\tab int t0[] = \{4,16,4,16,16\};\par
\tab\tab\tab p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));\par
\tab p1 = 2;\par
\tab all_right = KawigiEdit_RunTest(3, p0, true, p1) && all_right;\par
\tab // ------------------\par
\tab\}\par
\tab\par
\tab\{\par
\tab // ----- test 4 -----\par
\tab int t0[] = \{12,23,24,20,32\};\par
\tab\tab\tab p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));\par
\tab p1 = 2;\par
\tab all_right = KawigiEdit_RunTest(4, p0, true, p1) && all_right;\par
\tab // ------------------\par
\tab\}\par
\tab\par
\tab if (all_right) \{\par
\tab\tab cout << "You're a stud (at least on the example cases)!" << endl;\par
\tab\} else \{\par
\tab\tab cout << "Some of the test cases had errors." << endl;\par
\tab\}\par
\tab return 0;\par
\}\par
// END KAWIGIEDIT TESTING\par
//Powered by KawigiEdit 2.1.4 (beta) modified by pivanof!\par
\par
\par
\par
#include <vector>\par
#include <list>\par
#include <map>\par
#include <set>\par
#include <queue>\par
#include <deque>\par
#include <stack>\par
#include <bitset>\par
#include <algorithm>\par
#include <functional>\par
#include <numeric>\par
#include <utility>\par
#include <sstream>\par
#include <iostream>\par
#include <iomanip>\par
#include <cstdio>\par
#include <cmath>\par
#include <cstdlib>\par
#include <ctime>\par
#include <cstring>\par
\par
using namespace std;\par
\par
int opt[55][100005];\par
int e[55][55];\par
int p[55];\par
int n,cs,res;\par
\par
class SpaceshipEvacuation \{\par
public:\par
\tab\par
\tab void dfs(int u)\par
\tab\{\par
\tab\tab for (int v=0;v<n;v++)\par
\tab\tab if (e[u][v]>=0)\par
\tab\tab\{\par
\tab\tab\tab if (p[v]==-1)\par
\tab\tab\tab\{\par
\tab\tab\tab\tab p[v]=u;dfs(v);\par
\tab\tab\tab\} else\par
\tab\tab\tab if (v!=p[u])\par
\tab\tab\tab\{\par
\tab\tab\tab\tab int c[55],o=0;\par
\tab\tab\tab\tab c[0]=v;\par
\tab\tab\tab\tab for (int i=u;i!=v;i=p[i]) c[++o]=i;\par
\tab\tab\tab\tab c[++o]=v;\par
\tab\tab\tab\tab for (int i=1;i<o;i++)\par
\tab\tab\tab\tab\{\par
\tab\tab\tab\tab\tab int q=100000000;\par
\tab\tab\tab\tab\tab for (int j=0;j<=cs;j++)\par
\tab\tab\tab\tab\tab\{\par
\tab\tab\tab\tab\tab\tab q=min(q,opt[i-1][j]);\par
\tab\tab\tab\tab\tab\tab opt[i][j]=q+max(0,cs-j-e[c[i]][c[i-1]])+max(0,j-e[c[i]][c[i+1]]);\par
\tab\tab\tab\tab\tab\}\par
\tab\tab\tab\tab\}\par
\tab\tab\tab\tab int q=100000000;\par
\tab\tab\tab\tab for (int j=0;j<=cs;j++) q=min(q,opt[o-1][j]);\par
\tab\tab\tab\tab res+=q;\par
\tab\tab\tab\tab for (int j=0;j<o;j++) e[c[j]][c[j+1]]=e[c[j+1]][c[j]]=-1;\par
\tab\tab\tab\}\par
\tab\tab\}\par
\tab\}\par
\par
\tab int additionalCabins(int N, vector <string> t, int crewSize) \par
\tab\{\par
\tab\tab n=N;cs=crewSize;\par
\tab\tab memset(e,-1,sizeof(e));\par
\tab\tab memset(p,-1,sizeof(p));\par
\tab\tab memset(opt,0,sizeof(opt));\par
\tab\tab for (int i=0,a,b,c,d;i<t.size();i++)\par
\tab\tab\{\par
\tab\tab\tab stringstream sin;sin << t[i];\par
\tab\tab\tab sin >> a >> b >> c >> d;\par
\tab\tab\tab e[a][b]=c;e[b][a]=d;\par
\tab\tab\}\par
\tab\tab res=0;\par
\tab\tab p[0]=0;dfs(0);\par
\tab\tab\par
\tab\tab for (int i=0;i<n;i++)\par
\tab\tab for (int j=0;j<n;j++)\par
\tab\tab if (e[i][j]>=0 && p[j]==i)\par
\tab\tab\tab res+=max(0,cs-e[j][i]);\par
\tab\tab for (int i=0;i<n;i++) if (p[i]==-1) res=-1;\par
\tab\tab return res;\par
\tab\}\par
\};\par
\par
\par
// BEGIN KAWIGIEDIT TESTING\par
// Generated by KawigiEdit 2.1.4 (beta) modified by pivanof\par
bool KawigiEdit_RunTest(int testNum, int p0, vector <string> p1, int p2, bool hasAnswer, int p3) \{\par
\tab cout << "Test " << testNum << ": [" << p0 << "," << "\{";\par
\tab for (int i = 0; int(p1.size()) > i; ++i) \{\par
\tab\tab if (i > 0) \{\par
\tab\tab\tab cout << ",";\par
\tab\tab\}\par
\tab\tab cout << "\\"" << p1[i] << "\\"";\par
\tab\}\par
\tab cout << "\}" << "," << p2;\par
\tab cout << "]" << endl;\par
\tab SpaceshipEvacuation *obj;\par
\tab int answer;\par
\tab obj = new SpaceshipEvacuation();\par
\tab clock_t startTime = clock();\par
\tab answer = obj->additionalCabins(p0, p1, p2);\par
\tab clock_t endTime = clock();\par
\tab delete obj;\par
\tab bool res;\par
\tab res = true;\par
\tab cout << "Time: " << double(endTime - startTime) / CLOCKS_PER_SEC << " seconds" << endl;\par
\tab if (hasAnswer) \{\par
\tab\tab cout << "Desired answer:" << endl;\par
\tab\tab cout << "\\t" << p3 << endl;\par
\tab\}\par
\tab cout << "Your answer:" << endl;\par
\tab cout << "\\t" << answer << endl;\par
\tab if (hasAnswer) \{\par
\tab\tab res = answer == p3;\par
\tab\}\par
\tab if (!res) \{\par
\tab\tab cout << "DOESN'T MATCH!!!!" << endl;\par
\tab\} else if (double(endTime - startTime) / CLOCKS_PER_SEC >= 2) \{\par
\tab\tab cout << "FAIL the timeout" << endl;\par
\tab\tab res = false;\par
\tab\} else if (hasAnswer) \{\par
\tab\tab cout << "Match :-)" << endl;\par
\tab\} else \{\par
\tab\tab cout << "OK, but is it right?" << endl;\par
\tab\}\par
\tab cout << "" << endl;\par
\tab return res;\par
\}\par
int main() \{\par
\tab bool all_right;\par
\tab all_right = true;\par
\tab\par
\tab int p0;\par
\tab vector <string> p1;\par
\tab int p2;\par
\tab int p3;\par
\tab\par
\tab\{\par
\tab // ----- test 0 -----\par
\tab p0 = 3;\par
\tab string t1[] = \{"0 1 5 3","2 1 0 0"\};\par
\tab\tab\tab p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));\par
\tab p2 = 5;\par
\tab p3 = 7;\par
\tab all_right = KawigiEdit_RunTest(0, p0, p1, p2, true, p3) && all_right;\par
\tab // ------------------\par
\tab\}\par
\tab\par
\tab\{\par
\tab // ----- test 1 -----\par
\tab p0 = 3;\par
\tab string t1[] = \{"0 1 0 2","0 2 0 4"\};\par
\tab\tab\tab p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));\par
\tab p2 = 5;\par
\tab p3 = 4;\par
\tab all_right = KawigiEdit_RunTest(1, p0, p1, p2, true, p3) && all_right;\par
\tab // ------------------\par
\tab\}\par
\tab\par
\tab\{\par
\tab // ----- test 2 -----\par
\tab p0 = 4;\par
\tab string t1[] = \{"0 1 0 6","3 2 3 1","2 1 0 1","3 1 2 2"\};\par
\tab\tab\tab p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));\par
\tab p2 = 6;\par
\tab p3 = 6;\par
\tab all_right = KawigiEdit_RunTest(2, p0, p1, p2, true, p3) && all_right;\par
\tab // ------------------\par
\tab\}\par
\tab\par
\tab\{\par
\tab // ----- test 3 -----\par
\tab p0 = 10;\par
\tab string t1[] = \{"0 1 11 101","1 2 0 100","2 3 20 100","3 4 0 107","4 1 66 0","3 5 104 2","4 6 82 0","5 7 25 25","7 8 14 42","8 9 0 94","9 5 17 92"\};\par
\tab\tab\tab p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));\par
\tab p2 = 110;\par
\tab p3 = 376;\par
\tab all_right = KawigiEdit_RunTest(3, p0, p1, p2, true, p3) && all_right;\par
\tab // ------------------\par
\tab\}\par
\tab\par
\tab\{\par
\tab // ----- test 4 -----\par
\tab p0 = 3;\par
\tab string t1[] = \{"0 1 0 0"\};\par
\tab\tab\tab p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));\par
\tab p2 = 1;\par
\tab p3 = -1;\par
\tab all_right = KawigiEdit_RunTest(4, p0, p1, p2, true, p3) && all_right;\par
\tab // ------------------\par
\tab\}\par
\tab\par
\tab\{\par
\tab // ----- test 5 -----\par
\tab p0 = 10;\par
\tab string t1[] = \{"0 1 92810 31511","1 2 98614 91835","2 3 42746 99505","3 4 29873 92427","4 5 61969 36229","5 6 64224 1439","6 7 58352 72099","7 8 61130 9595","8 9 94497 32861","9 0 6701 52030"\};\par
\tab\tab\tab p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));\par
\tab p2 = 54124;\par
\tab p3 = 45984;\par
\tab all_right = KawigiEdit_RunTest(5, p0, p1, p2, true, p3) && all_right;\par
\tab // ------------------\par
\tab\}\par
\tab\par
\tab if (all_right) \{\par
\tab\tab cout << "You're a stud (at least on the example cases)!" << endl;\par
\tab\} else \{\par
\tab\tab cout << "Some of the test cases had errors." << endl;\par
\tab\}\par
\tab return 0;\par
\}\par
// END KAWIGIEDIT TESTING\par
//Powered by KawigiEdit 2.1.4 (beta) modified by pivanof!\par
\par
\par
#include <vector>\par
#include <list>\par
#include <map>\par
#include <set>\par
#include <queue>\par
#include <deque>\par
#include <stack>\par
#include <bitset>\par
#include <algorithm>\par
#include <functional>\par
#include <numeric>\par
#include <utility>\par
#include <sstream>\par
#include <iostream>\par
#include <cstring>\par
#include <iomanip>\par
#include <cstdio>\par
#include <cmath>\par
#include <cstdlib>\par
#include <ctime>\par
\par
using namespace std;\par
\par
bool g[55][55];\par
int mx[55],my[55],cx[55],cy[55];\par
int R[55];\par
int flag[55];\par
int res[55][55];\par
int n,m,nm,point;\par
\par
class TheContest \{\par
public:\par
\tab\par
\tab bool find(int u)\par
\tab\{\par
\tab\tab if (!u) return 1;\par
\tab\tab mx[u]=1;\par
\tab\tab for (int v=1;v<=m;v++)\par
\tab\tab if (g[u][v] && !my[v])\par
\tab\tab\{\par
\tab\tab\tab my[v]=1;\par
\tab\tab\tab if (!cy[v] || (!flag[cy[v]] && find(cy[v])))\par
\tab\tab\tab\{\par
\tab\tab\tab\tab cx[u]=v;cy[v]=u;return 1;\par
\tab\tab\tab\}\par
\tab\tab\}\par
\tab\tab return 0;\par
\tab\}\par
\tab\par
\tab bool check(int row,int col)\par
\tab\{\par
\tab\tab for (int i=col+1;i<=m;i++) cy[i]=0;\par
\tab\tab memset(cx,0,sizeof(cx));\par
\tab\tab for (int i=1;i<=col;i++) cx[cy[i]]=i;\par
\tab\tab\par
\tab\tab\par
\tab\tab int cnt=0;\par
\tab\tab for (int i=1;i<=nm;i++)\par
\tab\tab if (!flag[i] && (n>m && R[i]==n-row+1))\par
\tab\tab\{\par
\tab\tab\tab memset(mx,0,sizeof(mx));\par
\tab\tab\tab memset(my,0,sizeof(my));\par
\tab\tab\tab if (!find(i)) return 0;\par
\tab\tab\tab else cnt++;\par
\tab\tab\}\par
\tab\tab for (int i=1;i<=nm;i++)\par
\tab\tab if (!flag[i] && !cx[i])\par
\tab\tab\{\par
\tab\tab\tab memset(mx,0,sizeof(mx));\par
\tab\tab\tab memset(my,0,sizeof(my));\par
\tab\tab\tab cnt+=find(i);\par
\tab\tab\}\par
\tab\tab return cnt==m-col;\par
\tab\}\par
\tab\tab\par
\tab\tab\par
\tab\par
\tab vector <string> getSchedule(int N, int M) \par
\tab\{\par
\tab\tab memset(res,0,sizeof(res));\par
\tab\tab n=N;m=M;nm=max(n,m);\par
\tab\tab for (int i=1;i<=nm;i++)\par
\tab\tab for (int j=1;j<=m;j++)\par
\tab\tab\tab g[i][j]=1;\par
\tab\tab for (int j=1;j<=nm;j++) R[j]=min(n,m);\par
\tab\tab for (int i=1;i<=n;i++)\par
\tab\tab\{\par
\tab\tab\tab memset(flag,0,sizeof(flag));\par
\tab\tab\tab for (int j=1;j<=m;j++)\par
\tab\tab\tab\{\par
\tab\tab\tab\tab /*\par
\tab\tab\tab\tab for (int k=1;k<=nm;k++)\par
\tab\tab\tab\tab if (g[k][j] && !flag[k] && (n>m && R[k]==n-i+1))\par
\tab\tab\tab\tab\{\par
\tab\tab\tab\tab\tab res[i-1][j-1]=k;g[k][j]=0;flag[k]=1;R[k]--;cx[k]=j;cy[j]=k;\par
\tab\tab\tab\tab\tab if (check(i,j)) break;\par
\tab\tab\tab\tab\tab res[i-1][j-1]=0;g[k][j]=1;flag[k]=0;R[k]++;cx[k]=cy[j]=0;\par
\tab\tab\tab\tab\}\par
\tab\tab\tab\tab if (!res[i-1][j-1])\par
\tab\tab\tab\tab */\par
\tab\tab\tab\tab for (int k=1;k<=nm;k++)\par
\tab\tab\tab\tab if (g[k][j] && !flag[k])\par
\tab\tab\tab\tab\{\par
\tab\tab\tab\tab\tab res[i-1][j-1]=k;g[k][j]=0;flag[k]=1;R[k]--;cx[k]=j;cy[j]=k;\par
\tab\tab\tab\tab\tab if (check(i,j)) break;\par
\tab\tab\tab\tab\tab res[i-1][j-1]=0;g[k][j]=1;flag[k]=0;R[k]++;cx[k]=cy[j]=0;\par
\tab\tab\tab\tab\}\par
\tab\tab\tab\}\par
\tab\tab\}\par
\tab\tab\par
\tab\tab vector<string> p;p.clear();\par
\tab\tab for (int i=0;i<n;i++) p.push_back("");\par
\tab\tab for (int i=0;i<n;i++)\par
\tab\tab for (int j=0;j<m;j++)\par
\tab\tab if (res[i][j]<=9) p[i]+=char(res[i][j]+'0');else\par
\tab\tab if (res[i][j]<=35) p[i]+=char(res[i][j]+'A'-10);\par
\tab\tab else p[i]+=char(res[i][j]+'a'-36);\par
\tab\tab return p;\par
\tab\}\par
\};\par
\par
\par
// BEGIN KAWIGIEDIT TESTING\par
// Generated by KawigiEdit 2.1.4 (beta) modified by pivanof\par
bool KawigiEdit_RunTest(int testNum, int p0, int p1, bool hasAnswer, vector <string> p2) \{\par
\tab cout << "Test " << testNum << ": [" << p0 << "," << p1;\par
\tab cout << "]" << endl;\par
\tab TheContest *obj;\par
\tab vector <string> answer;\par
\tab obj = new TheContest();\par
\tab clock_t startTime = clock();\par
\tab answer = obj->getSchedule(p0, p1);\par
\tab clock_t endTime = clock();\par
\tab delete obj;\par
\tab bool res;\par
\tab res = true;\par
\tab cout << "Time: " << double(endTime - startTime) / CLOCKS_PER_SEC << " seconds" << endl;\par
\tab if (hasAnswer) \{\par
\tab\tab cout << "Desired answer:" << endl;\par
\tab\tab cout << "\\t" << "\{";\par
\tab\tab for (int i = 0; int(p2.size()) > i; ++i) \{\par
\tab\tab\tab if (i > 0) \{\par
\tab\tab\tab\tab cout << ",";\par
\tab\tab\tab\}\par
\tab\tab\tab cout << "\\"" << p2[i] << "\\"";\par
\tab\tab\}\par
\tab\tab cout << "\}" << endl;\par
\tab\}\par
\tab cout << "Your answer:" << endl;\par
\tab cout << "\\t" << "\{";\par
\tab for (int i = 0; int(answer.size()) > i; ++i) \{\par
\tab\tab if (i > 0) \{\par
\tab\tab\tab cout << ",";\par
\tab\tab\}\par
\tab\tab cout << "\\"" << answer[i] << "\\"";\par
\tab\}\par
\tab cout << "\}" << endl;\par
\tab if (hasAnswer) \{\par
\tab\tab if (answer.size() != p2.size()) \{\par
\tab\tab\tab res = false;\par
\tab\tab\} else \{\par
\tab\tab\tab for (int i = 0; int(answer.size()) > i; ++i) \{\par
\tab\tab\tab\tab if (answer[i] != p2[i]) \{\par
\tab\tab\tab\tab\tab res = false;\par
\tab\tab\tab\tab\}\par
\tab\tab\tab\}\par
\tab\tab\}\par
\tab\}\par
\tab if (!res) \{\par
\tab\tab cout << "DOESN'T MATCH!!!!" << endl;\par
\tab\} else if (double(endTime - startTime) / CLOCKS_PER_SEC >= 2) \{\par
\tab\tab cout << "FAIL the timeout" << endl;\par
\tab\tab res = false;\par
\tab\} else if (hasAnswer) \{\par
\tab\tab cout << "Match :-)" << endl;\par
\tab\} else \{\par
\tab\tab cout << "OK, but is it right?" << endl;\par
\tab\}\par
\tab cout << "" << endl;\par
\tab return res;\par
\}\par
int main() \{\par
\tab bool all_right;\par
\tab all_right = true;\par
\tab\par
\tab int p0;\par
\tab int p1;\par
\tab vector <string> p2;\par
\tab\par
\tab\{\par
\tab // ----- test 0 -----\par
\tab p0 = 3;\par
\tab p1 = 3;\par
\tab string t2[] = \{"123","231","312"\};\par
\tab\tab\tab p2.assign(t2, t2 + sizeof(t2) / sizeof(t2[0]));\par
\tab all_right = KawigiEdit_RunTest(0, p0, p1, true, p2) && all_right;\par
\tab // ------------------\par
\tab\}\par
\tab\par
\tab\{\par
\tab // ----- test 1 -----\par
\tab p0 = 4;\par
\tab p1 = 4;\par
\tab string t2[] = \{"1234","2143","3412","4321"\};\par
\tab\tab\tab p2.assign(t2, t2 + sizeof(t2) / sizeof(t2[0]));\par
\tab all_right = KawigiEdit_RunTest(1, p0, p1, true, p2) && all_right;\par
\tab // ------------------\par
\tab\}\par
\tab\par
\tab\{\par
\tab // ----- test 2 -----\par
\tab p0 = 4;\par
\tab p1 = 6;\par
\tab string t2[] = \{"123456","214365","345612","436521"\};\par
\tab\tab\tab p2.assign(t2, t2 + sizeof(t2) / sizeof(t2[0]));\par
\tab all_right = KawigiEdit_RunTest(2, p0, p1, true, p2) && all_right;\par
\tab // ------------------\par
\tab\}\par
\tab\par
\tab\{\par
\tab // ----- test 3 -----\par
\tab p0 = 5;\par
\tab p1 = 3;\par
\tab string t2[] = \{"123","214","345","451","532"\};\par
\tab\tab\tab p2.assign(t2, t2 + sizeof(t2) / sizeof(t2[0]));\par
\tab all_right = KawigiEdit_RunTest(3, p0, p1, true, p2) && all_right;\par
\tab // ------------------\par
\tab\}\par
\tab\par
\tab\{\par
\tab // ----- test 4 -----\par
\tab p0 = 28;\par
\tab p1 = 40;\par
\tab string t2[] = \{"123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcde","21436587A9CBEDGFIHKJMLONQPSRUTWVYXaZcbed","34127856BC9AFGDEJKHINOLMRSPQVWTUZaXYdebc","43218765CBA9GFEDKJIHONMLSRQPWVUTaZYXedcb","56781234DEFG9ABCLMNOHIJKTUVWPQRSbcdeXYZa","65872143EDGFA9CBMLONIHKJUTWVQPSRcbedYXaZ","78563412FGDEBC9ANOLMJKHIVWTURSPQdebcZaXY","87654321GFEDCBA9ONMLKJIHWVUTSRQPedcbaZYX","9ABCDEFG12345678PQRSTUVWXYZabcdeHIJKLMNO","A9CBEDGF21436587QPSRUTWVYXaZcbedIHKJMLON","BC9AFGDE34127856RSPQVWTUZaXYdebcJKHINOLM","CBA9GFED43218765SRQPWVUTaZYXedcbKJIHONML","DEFG9ABC56781234TUVWPQRSbcdeXYZaLMNOHIJK","EDGFA9CB65872143UTWVQPSRcbedYXaZMLONIHKJ","FGDEBC9A78563412VWTURSPQdebcZaXYNOLMJKHI","GFEDCBA987654321WVUTSRQPedcbaZYXONMLKJIH","HIJKLMNOPQRSTUVWXYZabcde123456789ABCDEFG","IHKJMLONQPSRUTWVYXaZcbed21436587A9CBEDGF","JKHINOLMRSPQVWTUZaXYdebc34127856BC9AFGDE","KJIHONMLSRQPWVUTaZYXedcb43218765CBA9GFED","LMNOHIJKTUVWPQRSbcdeXYZa56781234DEFG9ABC","MLONIHKJUTWVQPSRcbedYXaZ65872143EDGFA9CB","NOLMJKHIVWTURSPQdebcZaXY78563412FGDEBC9A","ONMLKJIHWVU"\par
\tab\tab\tab "TSRQPedcbaZYX87654321GFEDCBA9","PQRSTUVWXYZabcde9ABCDEFGHIJKLMNO12345678","QPSRUTWVYXaZcbedA9CBEDGFIHKJMLON21436587","RSPQVWTUZaXYdebcBC9AFGDEJKHINOLM34127856","SRQPWVUTaZYXedcbCBA9GFEDKJIHONML43218765"\};\par
\tab\tab\tab p2.assign(t2, t2 + sizeof(t2) / sizeof(t2[0]));\par
\tab all_right = KawigiEdit_RunTest(4, p0, p1, true, p2) && all_right;\par
\tab // ------------------\par
\tab\}\par
\tab\par
\tab if (all_right) \{\par
\tab\tab cout << "You're a stud (at least on the example cases)!" << endl;\par
\tab\} else \{\par
\tab\tab cout << "Some of the test cases had errors." << endl;\par
\tab\}\par
\tab return 0;\par
\}\par
// END KAWIGIEDIT TESTING\par
//Powered by KawigiEdit 2.1.4 (beta) modified by pivanof!\par
\par
\par
#include <vector>\par
#include <list>\par
#include <map>\par
#include <set>\par
#include <queue>\par
#include <deque>\par
#include <stack>\par
#include <bitset>\par
#include <algorithm>\par
#include <functional>\par
#include <numeric>\par
#include <utility>\par
#include <sstream>\par
#include <iostream>\par
#include <iomanip>\par
#include <cstdio>\par
#include <cmath>\par
#include <cstdlib>\par
#include <ctime>\par
\par
using namespace std;\par
\par
const int oo=100000000;\par
const char city[4]=\{'!','@','#','$'\};\par
const int dx[4]=\{1,0,-1,0\};\par
const int dy[4]=\{0,1,0,-1\};\par
\par
vector< pair<int,int> > pos[2505];\par
vector< pair<int,int> > e[2505];\par
int opt[2505][2505];\par
int cost[2505];\par
int que[1000000];\par
bool flag[2505];\par
int n,m;\par
int res;\par
int cnt[10][10];\par
\par
class BuildingRoads \{\par
public:\par
\tab\par
\tab void dfs(int now,int cc)\par
\tab\{\par
\tab\tab if (now>m/2)\par
\tab\tab\{\par
\tab\tab\tab int rs=0;\par
\tab\tab\tab for (int i=1;i<=cc;i++)\par
\tab\tab\tab\{\par
\tab\tab\tab\tab int s=0,rrs=oo;\par
\tab\tab\tab\tab for (int j=1;j<=cnt[i][0];j++) s+=(3<<((cnt[i][j]-1)*2));\par
\tab\tab\tab\tab for (int j=1;j<=n;j++) rrs=min(rrs,opt[s][j]);\par
\tab\tab\tab\tab rs+=rrs;\par
\tab\tab\tab\}\par
\tab\tab\tab res=min(res,rs);\par
\tab\tab\tab return;\par
\tab\tab\}\par
\tab\tab for (int i=1;i<=cc+1;i++)\par
\tab\tab\{\par
\tab\tab\tab cnt[i][++cnt[i][0]]=now;\par
\tab\tab\tab dfs(now+1,max(cc,i));\par
\tab\tab\tab cnt[i][0]--;\par
\tab\tab\}\par
\tab\}\par
\par
\tab int destroyRocks(vector <string> s) \par
\tab\{\par
\tab\tab //for (int i=0;i<2505;i++) pos[i].clear();\par
\par
\tab\tab int x=s.size(),y=s[0].size();n=m=0;\par
\tab\tab for (int k=0;k<4;k++)\par
\tab\tab for (int i=0;i<x;i++)\par
\tab\tab for (int j=0;j<y;j++)\par
\tab\tab if (s[i][j]==city[k])\par
\tab\tab\tab\{n++;m++;pos[n].clear();pos[n].push_back(make_pair(i,j));s[i][j]='^';cost[n]=0;\}\par
\tab\tab\par
\tab\tab for (int i=0;i<x;i++)\par
\tab\tab for (int j=0;j<y;j++)\par
\tab\tab if (s[i][j]!='^')\par
\tab\tab\{\par
\tab\tab\tab n++;pos[n].clear();pos[n].push_back(make_pair(i,j));\par
\tab\tab\tab char id=s[i][j];s[i][j]='^';\par
\tab\tab\tab if (id>='a' && id<='z') cost[n]=id-'a'+1;else\par
\tab\tab\tab if (id>='A' && id<='Z') cost[n]=(id-'A'+1)*100;else\par
\tab\tab\tab if (id>='1' && id<='9') cost[n]=(id-'0')*10000;else\par
\tab\tab\tab if (id=='0') cost[n]=100000;else cost[n]=0;\par
\tab\tab\tab for (int l=0;l<pos[n].size();l++)\par
\tab\tab\tab for (int k=0;k<4;k++)\par
\tab\tab\tab\{\par
\tab\tab\tab\tab int xx=pos[n][l].first+dx[k],yy=pos[n][l].second+dy[k];\par
\tab\tab\tab\tab if (xx>=0 && xx<x && yy>=0 && yy<y && s[xx][yy]==id)\par
\tab\tab\tab\tab\{\par
\tab\tab\tab\tab\tab s[xx][yy]='^';pos[n].push_back(make_pair(xx,yy));\par
\tab\tab\tab\tab\}\par
\tab\tab\tab\}\par
\tab\tab\}\par
\par
\tab\tab\par
\tab\tab //printf("%d %d\\n",pos[43].size(),e[43].size());\par
\par
\tab\tab for (int i=1;i<=n;i++) e[i].clear();\par
\tab\tab for (int i=1;i<=n;i++)\par
\tab\tab for (int j=1;j<=n;j++)\par
\tab\tab if (i!=j) \par
\tab\tab\{\par
\tab\tab\tab bool ok=0;\par
\tab\tab\tab for (int u=0;!ok && u<pos[i].size();u++)\par
\tab\tab\tab for (int v=0;!ok && v<pos[j].size();v++)\par
\tab\tab\tab\tab ok|=((abs(pos[i][u].first-pos[j][v].first)+abs(pos[i][u].second-pos[j][v].second))==1);\par
\tab\tab\tab if (ok) e[i].push_back(make_pair(j,cost[j]));\par
\tab\tab\}\par
\par
\tab\tab\par
\tab\tab\par
\tab\tab for (int i=0;i<(1<<m);i++)\par
\tab\tab for (int j=1;j<=n;j++)\par
\tab\tab\tab opt[i][j]=oo;\par
\tab\tab for (int i=0;i<m;i++) opt[1<<i][1+i]=0;\par
\tab\tab for (int i=1;i<(1<<m);i++)\par
\tab\tab\{\par
\tab\tab //\tab printf("%d\\n",i);\par
\tab\tab\tab for (int j=1;j<=n;j++)\par
\tab\tab\tab for (int k=1;k<i;k++)\par
\tab\tab\tab if ((i|k)==i)\par
\tab\tab\tab\{\par
\tab\tab\tab\tab opt[i][j]=min(opt[i][j],opt[k][j]+opt[i^k][j]-cost[j]);\par
\tab\tab\tab\tab //if (i==6 && j==12 && n>=50 && opt[6][12]==1492)\par
\tab\tab\tab\tab //\tab printf("%d %d %d %d- -\\n",k,opt[k][j],opt[i^k][j],cost[j]);\par
\tab\tab\tab\}\par
\tab\tab\tab\par
\tab\tab //\tab if (i==6 && n>=50 && opt[6][35]==2146)\par
\tab\tab //\tab\tab\tab printf("- -\\n");\par
\tab\tab\tab int *dist=opt[i];que[0]=0;\par
\tab\tab\tab //if (i==6 && n>=50)\par
\tab\tab\tab //\tab printf("%d \\n",dist[12]);\par
\tab\tab\tab\par
\tab\tab\tab //if (n>=50)\par
\tab\tab\tab //printf("@@@ %d %d\\n",i,e[43].size());\par
\par
\tab\tab\tab for (int j=1;j<=n;j++) flag[j]=0;\par
\tab\tab\tab for (int j=1;j<=n;j++)\par
\tab\tab\tab if (opt[i][j]<oo) flag[j]=1,que[++que[0]]=j;\par
\tab\tab\tab for (int l=1;l<=que[0];flag[que[l++]]=0)\par
\tab\tab\tab //for (vector< pair<int,int> > :: iterator it=e[que[l]].begin();it!=e[que[l]].end();it++)\par
\tab\tab\tab for (int it=0;it<e[que[l]].size();it++)\par
\tab\tab\tab //if (dist[it->first]>dist[que[l]]+(it->second))\par
\tab\tab\tab\{\par
\tab\tab\tab\tab //if (i==6 && n>=50 && e[43].size()>2)\par
\tab\tab\tab\tab //\tab printf("@");\par
\tab\tab\tab\tab //if (i==6 && n>=50 && l==13 && e[13][it].first==12)\par
\tab\tab\tab\tab //\tab printf("%d %d\\n",dist[12],dist[13]);\par
\tab\tab\tab\tab if (dist[e[que[l]][it].first]>dist[que[l]]+e[que[l]][it].second)\par
\tab\tab\tab\tab\{\par
\tab\tab\tab\tab\tab //dist[it->first]=dist[que[l]]+(it->second);\par
\tab\tab\tab\tab\tab dist[e[que[l]][it].first]=dist[que[l]]+e[que[l]][it].second;\par
\tab\tab\tab\tab //\tab if (i==4 && n>=50 && e[que[l]][it].first==20 && dist[20]==32)\par
\tab\tab\tab\tab //\tab\tab printf("%d %d %d- -\\n",e[que[l]].size(),que[l],e[que[l]][it].second);\par
\tab\tab\tab\tab\tab //if (i==6 && n>=50) printf("%d %d\\n",e[que[l]][it].first,dist[e[que[l]][it].first]);\par
\tab\tab\tab\tab\tab\par
\tab\tab\tab\tab\tab //if (!flag[it->first]) flag[(que[++que[0]]=(it->first))]=1;\par
\tab\tab\tab\tab\tab if (!flag[e[que[l]][it].first]) flag[que[++que[0]]=e[que[l]][it].first]=1;\par
\tab\tab\tab\tab\}\par
\tab\tab\tab\}\par
\par
\tab\tab\tab\par
\tab\tab\tab //if (i==6 && n>=50 && opt[6][35]==2146)\par
\tab\tab\tab //\tab\tab printf("# #\\n");\par
\tab\tab\}\par
\tab\tab res=oo;\par
\tab //\tab printf("%d\\n",opt[4][43]);\par
\tab //\tab printf("%d\\n",opt[6][35]);\par
\tab //\tab printf("%d %d\\n",opt[14][1],opt[1][1]);\par
\tab\tab for (int i=1;i<=n;i++) \par
\tab\tab\{\par
\tab\tab\tab res=min(res,opt[(1<<m)-1][i]);\par
\tab\tab //\tab if (res==2146)\par
\tab\tab //\tab\{\par
\tab\tab //\tab\tab cout << i << endl;\par
\tab\tab //\tab\tab break;\par
\tab\tab //\tab\}\par
\tab\tab\}\par
\tab\tab cout << res << endl;\par
\tab\tab\par
\tab\tab for (int i=1;i<=m;i++) cnt[i][0]=0;\par
\tab\tab res=oo;\par
\tab\tab dfs(1,0);\par
\tab\tab return res;\par
\tab\tab\par
\tab\}\par
\};\par
\par
\par
// BEGIN KAWIGIEDIT TESTING\par
// Generated by KawigiEdit 2.1.4 (beta) modified by pivanof\par
bool KawigiEdit_RunTest(int testNum, vector <string> p0, bool hasAnswer, int p1) \{\par
\tab cout << "Test " << testNum << ": [" << "\{";\par
\tab for (int i = 0; int(p0.size()) > i; ++i) \{\par
\tab\tab if (i > 0) \{\par
\tab\tab\tab cout << ",";\par
\tab\tab\}\par
\tab\tab cout << "\\"" << p0[i] << "\\"";\par
\tab\}\par
\tab cout << "\}";\par
\tab cout << "]" << endl;\par
\tab BuildingRoads *obj;\par
\tab int answer;\par
\tab obj = new BuildingRoads();\par
\tab clock_t startTime = clock();\par
\tab answer = obj->destroyRocks(p0);\par
\tab clock_t endTime = clock();\par
\tab delete obj;\par
\tab bool res;\par
\tab res = true;\par
\tab cout << "Time: " << double(endTime - startTime) / CLOCKS_PER_SEC << " seconds" << endl;\par
\tab if (hasAnswer) \{\par
\tab\tab cout << "Desired answer:" << endl;\par
\tab\tab cout << "\\t" << p1 << endl;\par
\tab\}\par
\tab cout << "Your answer:" << endl;\par
\tab cout << "\\t" << answer << endl;\par
\tab if (hasAnswer) \{\par
\tab\tab res = answer == p1;\par
\tab\}\par
\tab if (!res) \{\par
\tab\tab cout << "DOESN'T MATCH!!!!" << endl;\par
\tab\} else if (double(endTime - startTime) / CLOCKS_PER_SEC >= 2) \{\par
\tab\tab cout << "FAIL the timeout" << endl;\par
\tab\tab res = false;\par
\tab\} else if (hasAnswer) \{\par
\tab\tab cout << "Match :-)" << endl;\par
\tab\} else \{\par
\tab\tab cout << "OK, but is it right?" << endl;\par
\tab\}\par
\tab cout << "" << endl;\par
\tab return res;\par
\}\par
int main() \{\par
\tab bool all_right;\par
\tab all_right = true;\par
\tab\par
\tab vector <string> p0;\par
\tab int p1;\par
\tab\par
\tab\{\par
\tab // ----- test 0 -----\par
\tab string t0[] = \{"!1.!","aab2"\};\par
\tab\tab\tab p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));\par
\tab p1 = 3;\par
\tab all_right = KawigiEdit_RunTest(0, p0, true, p1) && all_right;\par
\tab // ------------------\par
\tab\}\par
\tab\par
\tab\{\par
\tab // ----- test 1 -----\par
\tab string t0[] = \{"#@","A.","A1","@#"\};\par
\tab\tab\tab p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));\par
\tab p1 = 100;\par
\tab all_right = KawigiEdit_RunTest(1, p0, true, p1) && all_right;\par
\tab // ------------------\par
\tab\}\par
\tab\par
\tab\{\par
\tab // ----- test 2 -----\par
\tab string t0[] = \{"$....","BBBBB","B000B","B0$0B","B000B","BBBBB"\};\par
\tab\tab\tab p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));\par
\tab p1 = 100200;\par
\tab all_right = KawigiEdit_RunTest(2, p0, true, p1) && all_right;\par
\tab // ------------------\par
\tab\}\par
\tab\par
\tab\{\par
\tab // ----- test 3 -----\par
\tab string t0[] = \{"$a",".B","$3"\};\par
\tab\tab\tab p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));\par
\tab p1 = 0;\par
\tab all_right = KawigiEdit_RunTest(3, p0, true, p1) && all_right;\par
\tab // ------------------\par
\tab\}\par
\tab\par
\tab\{\par
\tab // ----- test 4 -----\par
\tab string t0[] = \{".#!@.$",".11111","..AB..","33AB..","$3AB..","88888a","#!@..."\};\par
\tab\tab\tab p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));\par
\tab p1 = 30301;\par
\tab all_right = KawigiEdit_RunTest(4, p0, true, p1) && all_right;\par
\tab // ------------------\par
\tab\}\par
\tab\par
\tab\{\par
\tab // ----- test 5 -----\par
\tab string t0[] = \{".........iii.........Oooo.Y....fff.SS",".........i.H........OOYYYYY....ffffSS","..2..F..iiHHH.H.@..OOOOYYY.Bnnnfffff.","..22.FF.iiHHHHHHNNNN7O.YY..Bnnnfffff.","2222FFFFiiiHHHHHNNNN7O..P..nn.fffff.!","222...FFiEEEHHHccNN!7DDPPP.nnn.GGG...","22h.FFFFjjEErrHTc6.77DPPPP..nJ.GGG...","hhhhFFF.mEEErTTTcc.77DPPPP.JJJJ@GG...","hkk.FmmmmmmmruuubbbzzDDPPP.JJJJJ.....","kkkRR.mmmmmmr.uuuuzzzzzLL.JJJJJJ.....","kkkkkmmmmm.m.uuuuzzzzzzz...JJJJJ....."\};\par
\tab\tab\tab p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));\par
\tab p1 = 2428;\par
\tab all_right = KawigiEdit_RunTest(5, p0, true, p1) && all_right;\par
\tab // ------------------\par
\tab\}\par
\tab\par
\tab if (all_right) \{\par
\tab\tab cout << "You're a stud (at least on the example cases)!" << endl;\par
\tab\} else \{\par
\tab\tab cout << "Some of the test cases had errors." << endl;\par
\tab\}\par
\tab return 0;\par
\}\par
// END KAWIGIEDIT TESTING\par
//Powered by KawigiEdit 2.1.4 (beta) modified by pivanof!\par
\par
\par
#include <cstdio>\par
#include <algorithm>\par
#include <vector>\par
#include <string>\par
#include <queue>\par
using namespace std;\par
class BuildingRoads\{\par
public:\par
\tab static const int NMax=50;\par
\tab static const int VMax=70;\par
\tab static const int CMax=8;\par
\tab int N,M;\par
\tab int Map[NMax][NMax+1];\par
\tab int cost[128],city[128];\par
\tab int color[NMax][NMax],cityid[VMax],vcost[VMax];\par
\tab int V;\par
\tab int Dist[VMax][VMax];\par
\tab int dp[VMax][1<<CMax];\par
\tab //\'b0\'d1\'c8\'f4\'b8\'c9\'b8\'f6\'b3\'c7\'ca\'d0\'bc\'af\'d6\'d0\'b5\'bd\'c4\'b3\'b5\'e3\'b5\'c4\'d7\'ee\'d0\'a1\'b4\'fa\'bc\'db\par
\tab int ret;\par
\tab int dp2[1<<CMax];\par
\tab void dfs(int left,int cur)\{\par
\tab\tab //\'c3\'b6\'be\'d9\'c8\'e7\'ba\'ce\'b2\'f0\'b7\'d6\'b3\'c7\'ca\'d0\par
\tab\tab if (!left)ret=min(ret,cur);\par
\tab\tab else\{\par
\tab\tab\tab int t=left&-left;\par
\tab\tab\tab for (int i=0;i<(1<<CMax);i++)\par
\tab\tab\tab\tab if ((i&left)==i && (i&t)==t)\par
\tab\tab\tab\tab\tab dfs(left-i,cur+dp2[i*3]);\par
\tab\tab\}\par
\tab\}\par
\tab int destroyRocks(vector<string> field)\{\par
\tab\tab for (int i=0;i<128;i++)cost[i]=0,city[i]=-1;\par
\tab\tab city[(int)'!']=0;city[(int)'@']=1;city[(int)'#']=2;city[(int)'$']=3;\par
\tab\tab for (int i='a';i<='z';i++)cost[i]=i-'a'+1;\par
\tab\tab for (int i='A';i<='Z';i++)cost[i]=(i-'A'+1)*100;\par
\tab\tab for (int i='0';i<='9';i++)cost[i]=(i-'0')*10000;\par
\tab\tab cost[(int)'0']=100000;\par
\tab\tab N=field.size();M=field[0].length();\par
\tab\tab for (int i=0;i<N;i++)\{\par
\tab\tab\tab for (int j=0;j<M;j++)Map[i][j]=field[i][j];\par
\tab\tab\tab Map[i][M]=0;\par
\tab\tab\}\par
\tab\tab for (int i=0;i<N;i++)for (int j=0;j<M;j++)color[i][j]=-1;\par
\tab\tab V=0;\par
\tab\tab for (int i=0;i<N;i++)for (int j=0;j<M;j++)if (color[i][j]==-1 && (city[Map[i][j]]!=-1 || cost[Map[i][j]]))\{\par
\tab\tab\tab //bfs\'d5\'d2\'c1\'ac\'cd\'a8\'bf\'e9\par
\tab\tab\tab queue<pair<int,int> >Q;\par
\tab\tab\tab color[i][j]=V;Q.push(make_pair(i,j));\par
\tab\tab\tab if (cost[Map[i][j]])\{\par
\tab\tab\tab\tab while (!Q.empty())\{\par
\tab\tab\tab\tab\tab int x=Q.front().first,y=Q.front().second;\par
\tab\tab\tab\tab\tab Q.pop();\par
\tab\tab\tab\tab\tab for (int u=max(0,x-1);u<=min(N-1,x+1);u++)\par
\tab\tab\tab\tab\tab for (int v=max(0,y-1);v<=min(M-1,y+1);v++)\{\par
\tab\tab\tab\tab\tab if ((u==x && v!=y) || (u!=x && v==y))\par
\tab\tab\tab\tab\tab if (Map[x][y]==Map[u][v])\par
\tab\tab\tab\tab\tab\tab if (color[u][v]==-1)\{\par
\tab\tab\tab\tab\tab\tab\tab color[u][v]=V;\par
\tab\tab\tab\tab\tab\tab\tab Q.push(make_pair(u,v));\par
\tab\tab\tab\tab\tab\tab\}\par
\tab\tab\tab\tab\tab\}\par
\tab\tab\tab\tab\}\par
\tab\tab\tab\}\par
\tab\tab\tab V++;\par
\tab\tab\}\par
\tab\tab for (int i=0;i<V;i++)for (int j=0;j<V;j++)\par
\tab\tab\tab Dist[i][j]=~0u>>2;\par
\tab\tab for (int i=0;i<V;i++)Dist[i][i]=0;\par
\tab\tab for (int i=0;i<V;i++)\{\par
\tab\tab\tab //bfs\'bc\'c6\'cb\'e3\'be\'e0\'c0\'eb\par
\tab\tab\tab int x=-1,y=-1;\par
\tab\tab\tab static int buf[NMax][NMax];\par
\tab\tab\tab for (int j=0;j<N;j++)for (int k=0;k<M;k++)\{\par
\tab\tab\tab\tab buf[j][k]=0;\par
\tab\tab\tab\tab if (color[j][k]==i)x=j,y=k;\par
\tab\tab\tab\}\par
\tab\tab\tab queue<pair<int,int> >Q;\par
\tab\tab\tab Q.push(make_pair(x,y));buf[x][y]=1;\par
\tab\tab\tab while (!Q.empty())\{\par
\tab\tab\tab\tab x=Q.front().first,y=Q.front().second;\par
\tab\tab\tab\tab Q.pop();\par
\tab\tab\tab\tab for (int u=max(0,x-1);u<=min(N-1,x+1);u++)\par
\tab\tab\tab\tab for (int v=max(0,y-1);v<=min(M-1,y+1);v++)\par
\tab\tab\tab\tab if ((u==x && v!=y) || (u!=x && v==y))\par
\tab\tab\tab\tab if (!buf[u][v])\{\par
\tab\tab\tab\tab\tab buf[u][v]=1;\par
\tab\tab\tab\tab\tab if (color[u][v]!=-1)\par
\tab\tab\tab\tab\tab\tab Dist[i][color[u][v]]=min(Dist[i][color[u][v]],cost[Map[u][v]]);\par
\tab\tab\tab\tab\tab if (color[u][v]==i || !cost[Map[u][v]])\{\par
\tab\tab\tab\tab\tab\tab Q.push(make_pair(u,v));\par
\tab\tab\tab\tab\tab\}\par
\tab\tab\tab\tab\}\par
\tab\tab\tab\}\par
\tab\tab\}\par
\tab\tab //\'bc\'c6\'cb\'e3\'d7\'ee\'b6\'cc\'c2\'b7\par
\tab\tab for (int i=0;i<V;i++)\par
\tab\tab\tab for (int j=0;j<V;j++)\par
\tab\tab\tab\tab for (int k=0;k<V;k++)\par
\tab\tab\tab\tab\tab Dist[j][k]=min(Dist[j][k],Dist[j][i]+Dist[i][k]);\par
\tab\tab int c4[4]=\{0,0,0,0\};\par
\tab\tab for (int i=0;i<V;i++)vcost[i]=0,cityid[i]=-1;\par
\tab\tab for (int i=0;i<N;i++)for (int j=0;j<M;j++)\{\par
\tab\tab\tab if (city[Map[i][j]]!=-1)\{\par
\tab\tab\tab\tab cityid[color[i][j]]=city[Map[i][j]]*2+c4[city[Map[i][j]]];\par
\tab\tab\tab\tab c4[city[Map[i][j]]]++;\par
\tab\tab\tab\}\par
\tab\tab\tab if (color[i][j]!=-1)\par
\tab\tab\tab\tab vcost[color[i][j]]=cost[Map[i][j]];\par
\tab\tab\}\par
\tab\tab for (int i=0;i<(1<<CMax);i++)\{\par
\tab\tab\tab for (int j=0;j<V;j++)\{\par
\tab\tab\tab\tab //\'bb\'ae\'b7\'d6\'d7\'d3\'bc\'af\par
\tab\tab\tab\tab if (i==0)dp[j][i]=vcost[j];\par
\tab\tab\tab\tab else if (i==(i&-i))\{\par
\tab\tab\tab\tab\tab int t=__builtin_ctz(i);\par
\tab\tab\tab\tab\tab if (cityid[j]==t)dp[j][i]=vcost[j];\par
\tab\tab\tab\tab\tab else dp[j][i]=~0u>>2;\par
\tab\tab\tab\tab\}else\{\par
\tab\tab\tab\tab\tab dp[j][i]=~0u>>2;\par
\tab\tab\tab\tab\tab for (int k=0;;)\{\par
\tab\tab\tab\tab\tab\tab dp[j][i]=min(dp[j][i],dp[j][k]+dp[j][i-k]-vcost[j]);\par
\tab\tab\tab\tab\tab\tab int t=(i-k)&(k-i);\par
\tab\tab\tab\tab\tab\tab if (!t)break;\par
\tab\tab\tab\tab\tab\tab k|=t;\par
\tab\tab\tab\tab\tab\tab k&=~(t-1);\par
\tab\tab\tab\tab\tab\}\par
\tab\tab\tab\tab\}\par
\tab\tab\tab\}\par
\tab\tab\tab //\'d1\'d3\'c9\'ec\'d2\'bb\'b8\'f6\'c9\'fa\'b3\'c9\'ca\'f7\par
\tab\tab\tab for (int j=0;j<V;j++)for (int k=0;k<V;k++)\par
\tab\tab\tab\tab dp[j][i]=min(dp[j][i],dp[k][i]+Dist[k][j]);\par
\tab\tab\tab dp2[i]=~0u>>2;\par
\tab\tab\tab for (int j=0;j<V;j++)dp2[i]=min(dp2[i],dp[j][i]);\par
\tab\tab\}\par
\tab\tab ret=~0u>>2;\par
\tab\tab int citys=0;\par
\tab\tab for (int i=0;i<4;i++)if (c4[i])citys|=(1<<(i+i));\par
\tab\tab dfs(citys,0);\par
\tab\tab return ret;\par
\tab\}\par
\}me;\par
int main()\par
\{\par
\tab char *chs[]=\par
\{".#!@.$",\par
 ".11111",\par
 "..AB..",\par
 "33AB..",\par
 "$3AB..",\par
 "88888a",\par
 "#!@..."\}\par
 ;\par
\tab printf("%d\\n",me.destroyRocks(vector<string>(chs,chs+(sizeof(chs)/sizeof(chs[0])))));\par
\tab return 0;\par
\}\par
\par
\par
#include <cstdio>\par
#include <algorithm>\par
#include <string>\par
#include <vector>\par
using namespace std;\par
const char* chs="123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";\par
class TheContest\{\par
public:\par
\tab static const int NMax=50;\par
\tab int N,n,m;\par
\tab int R[NMax][NMax];\par
\tab int M[NMax][NMax];\par
\tab int X[NMax],Y[NMax],Perm[NMax];\par
\tab int used[NMax],degree[NMax];\par
\tab int dfs(int a)\{\par
\tab\tab //\'d4\'f6\'b9\'e3\par
\tab\tab used[a]=1;\par
\tab\tab for (int i=0;i<N;i++)if (M[i][a] && X[i]>=-1)if (X[i]==-1 || (used[X[i]]==0 && dfs(X[i])))\{\par
\tab\tab\tab X[i]=a;Y[a]=i;\par
\tab\tab\tab return 1;\par
\tab\tab\}\par
\tab\tab return 0;\par
\tab\}\par
\tab void dfs2(int a)\{\par
\tab\tab //\'bc\'c6\'cb\'e3\'d2\'bb\'b8\'f6\'b5\'e3\'bf\'c9\'d2\'d4\'c6\'a5\'c5\'e4\'b5\'c4\'b5\'e3\par
\tab\tab used[a]=1;\par
\tab\tab for (int i=0;i<N;i++)if (M[i][a])if (X[i]>=0 && used[X[i]]==0)dfs2(X[i]);\par
\tab\}\par
\tab void BiMatch()\{\par
\tab\tab //\'d7\'ee\'b4\'f3\'c6\'a5\'c5\'e4\par
\tab\tab for (int i=0;i<N;i++)X[i]=-1;\par
\tab\tab for (int i=0;i<N;i++)Y[i]=-1;\par
\tab\tab for (int i=0;i<N;i++)if (degree[i]==0)\{\par
\tab\tab\tab //\'d3\'d0\'d0\'a9\'b5\'e3\'b1\'d8\'d0\'eb\'c6\'a5\'c5\'e4\'a3\'ac\'d2\'d4\'b1\'e3\'ca\'a3\'cf\'c2\'b5\'c4\'d0\'d0\'d3\'d0\'bd\'e2\par
\tab\tab\tab for (int j=0;j<N;j++)used[j]=0;\par
\tab\tab\tab dfs(i);\par
\tab\tab\}\par
\tab\tab for (int i=0;i<N;i++)if (Y[i]==-1)\{\par
\tab\tab\tab for (int j=0;j<N;j++)used[j]=0;\par
\tab\tab\tab dfs(i);\par
\tab\tab\}\par
\tab\tab for (int i=0;i<m;i++)\{\par
\tab\tab\tab for (int j=0;j<N;j++)used[j]=0;\par
\tab\tab\tab dfs2(X[i]);\par
\tab\tab\tab int k;\par
\tab\tab\tab //\'d1\'b0\'d5\'d2\'d7\'d6\'b5\'e4\'d0\'f2\'d7\'ee\'ba\'c3\'b5\'c4\par
\tab\tab\tab for (k=0;!used[k] || !M[i][k];k++);\par
\tab\tab\tab Perm[i]=k;\par
\tab\tab\tab int l=Y[k],r=X[i];\par
\tab\tab\tab Y[r]=-1;X[l]=-1;\par
\tab\tab\tab X[i]=-2;Y[k]=-2;\par
\tab\tab\tab for (int j=0;j<N;j++)used[j]=0;\par
\tab\tab\tab if (Y[r]==-1)dfs(r);\par
\tab\tab\}\par
\tab\}\par
\tab vector<string> getSchedule(int _n,int _m)\{\par
\tab\tab n=_n;m=_m;\par
\tab\tab N=max(n,m);\par
\tab\tab for (int i=0;i<N;i++)degree[i]=N-m;\par
\tab\tab for (int i=0;i<m;i++)for (int j=0;j<N;j++)\par
\tab\tab\tab M[i][j]=1;\par
\tab\tab for (int i=0;i<n;i++)\{\par
\tab\tab\tab for (int j=0;j<N;j++)\par
\tab\tab\tab\tab for (int k=m;k<N;k++)\par
\tab\tab\tab\tab\tab M[k][j]=(degree[j]!=0);\par
\tab\tab\tab BiMatch();\par
\tab\tab\tab for (int j=0;j<N;j++)degree[j]--;\par
\tab\tab\tab for (int j=0;j<m;j++)R[i][j]=Perm[j],M[j][Perm[j]]=0,degree[Perm[j]]++;\par
\tab\tab\}\par
\tab\tab vector<string> ret;\par
\tab\tab for (int i=0;i<n;i++)\{\par
\tab\tab\tab string tmp;\par
\tab\tab\tab for (int j=0;j<m;j++)\{\par
\tab\tab\tab\tab tmp+=chs[R[i][j]];\par
\tab\tab\tab\}\par
\tab\tab\tab puts(&tmp[0]);\par
\tab\tab\tab ret.push_back(tmp);\par
\tab\tab\}\par
\tab\tab return ret;\par
\tab\}\par
\}me;\par
int work()\{\par
\tab me.getSchedule(50,49);\par
\tab return 0;\par
\}\par
int main()\{return work();\}\par
\par
\par
\par
\par
\par
\par
\par
#include <cstdio>\par
#include <algorithm>\par
#include <vector>\par
#include <string>\par
using namespace std;\par
class SpaceshipEvacuation\{\par
public:\par
\tab static const int NMax=50;\par
\tab static const int CMax=100000;\par
\tab bool Map[NMax][NMax],special[NMax];\par
\tab char used[NMax];\par
\tab int Flow[NMax][NMax],father[NMax];\par
\tab int N,C,ret;\par
\tab void work_circle(int a)\{\par
\tab\tab //\'d3\'c3dp\'bc\'c6\'cb\'e3\'d2\'bb\'b8\'f6\'bb\'b7\'c9\'cf\'b5\'c4\'b4\'f0\'b0\'b8\par
\tab\tab vector<int> list;\par
\tab\tab for (int i=a;;i=father[i])\{\par
\tab\tab\tab list.push_back(i);\par
\tab\tab\tab if (special[i])\{\par
\tab\tab\tab\tab if (father[i]!=-1)\par
\tab\tab\tab\tab\tab ret+=max(0,C-Flow[i][father[i]]);\par
\tab\tab\tab\tab break;\par
\tab\tab\tab\}\par
\tab\tab\tab special[i]=true;\par
\tab\tab\}\par
\tab\tab static int dp[NMax][CMax+1];\par
\tab\tab //\'c7\'b0\'c8\'f4\'b8\'c9\'b8\'f6\'bd\'da\'b5\'e3\'a3\'ac\'cb\'fc\'c3\'c7\'b5\'c4\'c6\'bf\'be\'b1\'c8\'dd\'c1\'bf\'ca\'c7\'c8\'f4\'b8\'c9\'b5\'c4\'c7\'e9\'bf\'f6\'cf\'c2\'d7\'ee\'d0\'a1\'b4\'fa\'bc\'db\par
\tab\tab int lc=list.size();\par
\tab\tab for (int i=0;i<=C;i++)dp[lc-1][i]=0;\par
\tab\tab for (int i=lc-2;i>=0;i--)\{\par
\tab\tab\tab int a=Flow[list[i]][list[i==0?lc-1:i-1]],b=Flow[list[i]][list[i+1]];\par
\tab\tab\tab int tmp=~0u>>1;\par
\tab\tab\tab for (int j=0;j<=C;j++)\{\par
\tab\tab\tab\tab tmp=min(tmp,dp[i+1][j]);\par
\tab\tab\tab\tab dp[i][j]=tmp+max(0,j-a)+max(0,C-b-j);\par
\tab\tab\tab\}\par
\tab\tab\}\par
\tab\tab int r=~0u>>2;\par
\tab\tab for (int i=0;i<=C;i++)r=min(r,dp[0][i]);\par
\tab\tab ret+=r;\par
\tab\}\par
\tab void dfs(int a)\{\par
\tab\tab //\'d5\'d2\'bb\'b7\par
\tab\tab used[a]=1;\par
\tab\tab for (int i=0;i<N;i++)if (Map[a][i] && i!=father[a])\{\par
\tab\tab\tab if (used[i]==1)special[i]=true,work_circle(a);\par
\tab\tab\tab else if (used[i]==0)\{\par
\tab\tab\tab\tab father[i]=a;\par
\tab\tab\tab\tab dfs(i);\par
\tab\tab\tab\}\par
\tab\tab\}\par
\tab\tab used[a]=2;\par
\tab\tab if (!special[a] && father[a]!=-1)\par
\tab\tab\tab ret+=max(0,C-Flow[a][father[a]]);\par
\tab\}\par
\tab int additionalCabins(int _N,vector<string> tunnelNetwork,int crewSize)\{\par
\tab\tab N=_N;C=crewSize;\par
\tab\tab for (int i=0;i<N;i++)for (int j=0;j<N;j++)\par
\tab\tab\tab Map[i][j]=false,Flow[i][j]=0;\par
\tab\tab for (vector<string>::iterator i=tunnelNetwork.begin();i!=tunnelNetwork.end();i++)\{\par
\tab\tab\tab int x,y,a,b;\par
\tab\tab\tab sscanf(&((*i)[0]),"%d%d%d%d",&x,&y,&a,&b);\par
\tab\tab\tab Map[x][y]=Map[y][x]=true;\par
\tab\tab\tab Flow[x][y]=a;Flow[y][x]=b;\par
\tab\tab\}\par
\tab\tab for (int i=0;i<N;i++)used[i]=0,father[i]=-1,special[i]=false;\par
\tab\tab dfs(0);\par
\tab\tab for (int i=0;i<N;i++)if (used[i]==0)return -1;\par
\tab\tab return ret;\par
\tab\}\par
\}me;\par
int main()\par
\{\par
\tab char* a[]=\par
\{"0 1 0 0"\}\par
;\par
\tab printf("%d\\n",me.additionalCabins(3,vector<string>(a,a+sizeof(a)/sizeof(a[0])),1));\par
\tab return 0;\par
\}\par
\par
}
 